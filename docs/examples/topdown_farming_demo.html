<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topdown Farming Demo - LunaEngine Examples</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="../theme.css" rel="stylesheet">
</head>
<body>
    
    <nav class="navbar navbar-expand-lg navbar-light sticky-top">
        <div class="container">
            <a class="navbar-brand fw-bold" href="../index.html" id="navbar-logo-link">
                <i class="bi bi-moon-stars-fill me-2"></i>
                LunaEngine
            </a>
            <div class="d-flex align-items-center">
                <div class="input-group me-3">
                    <input type="text" id="moduleSearch" class="form-control" placeholder="Search functions, classes, methods...">
                    <span class="input-group-text" id="searchIcon"><i class="bi bi-search"></i></span>
                </div>
                
                <button class="btn btn-outline-secondary theme-toggle">
                    <span class="theme-icon">ðŸŒ™</span>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container mt-5">
        <nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../index.html">Home</a></li><li class="breadcrumb-item"><a href="index.html">Examples Hub</a></li><li class="breadcrumb-item active">Topdown Farming Demo</li></ol></nav>
        
        <div class="row">
            <div class="col-lg-8">
                <h1 class="mb-3"><i class="bi bi-code-slash me-2"></i>Topdown Farming Demo</h1>
                <div class="card mb-4 shadow-sm">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0"><i class="bi bi-file-earmark-code me-2"></i>topdown_farming_demo.py</h5>
                    </div>
                    <div class="card-body">
                        <pre><code class="language-python">&quot;&quot;&quot;
topdown_farming_demo.py - Top-Down Farming Game Demo with Optimized Shadows

Downgraded to 0.1.4 (0.1.4.2)
&quot;&quot;&quot;

import sys
import os
import random
import math
import numpy as np
sys.path.append(os.path.join(os.path.dirname(__file__), &#x27;..&#x27;))

from lunaengine.core import LunaEngine, Scene
from lunaengine.ui.elements import *
from lunaengine.graphics.camera import Camera, CameraMode
from lunaengine.graphics.particles import ParticleSystem, ParticleConfig, ExitPoint, PhysicsType
from lunaengine.graphics.shadows import ShadowSystem, Light, ShadowCaster
from lunaengine.utils import distance
import pygame

class TopDownFarmingGame(Scene):
    &quot;&quot;&quot;Top-Down Farming and Collection Game with Optimized Shadows&quot;&quot;&quot;
    
    def __init__(self, engine: LunaEngine):
        super().__init__(engine)
        
        # Game state
        self.game_state = {
            &#x27;money&#x27;: 100,
            &#x27;inventory&#x27;: {
                &#x27;wood&#x27;: 0,
                &#x27;stone&#x27;: 0,
                &#x27;wheat&#x27;: 0,
                &#x27;corn&#x27;: 0
            },
            &#x27;seeds&#x27;: {
                &#x27;wheat&#x27;: 5,
                &#x27;corn&#x27;: 3
            },
            &#x27;selected_tool&#x27;: &#x27;axe&#x27;,
            &#x27;selected_seed&#x27;: &#x27;wheat&#x27;,
            &#x27;day_time&#x27;: 0.25,  # Start in morning
            &#x27;day_count&#x27;: 1
        }
        
        # World configuration
        self.world_size = (2000, 2000)
        self.cell_size = 40
        
        # Initialize game entities
        self.player = None
        self.trees = []
        self.rocks = []
        self.farm_plots = []
        self.crops = []
        self.market_stall = None
        self.seed_shop = None
        
        # Shadow system control
        self.shadows_enabled = True
        self.shadow_quality = &quot;medium&quot;  # low, medium, high
        
        # Generate world (BEFORE setting up camera)
        self.setup_parallax()
        self.generate_world()
        
        # Configure camera (AFTER generating world)
        self.setup_camera()
        
        # Setup shadow system (AFTER camera and world)
        self.setup_shadows()
        
        # Setup UI
        self.setup_ui()

    def setup_shadows(self):
        &quot;&quot;&quot;Setup optimized shadow system&quot;&quot;&quot;
        # Configure shadow system based on quality
        if self.shadow_quality == &quot;low&quot;:
            self.shadow_system.max_cache_size = 3
            self.shadow_update_frequency = 3  # Update every 3 frames
        elif self.shadow_quality == &quot;medium&quot;:
            self.shadow_system.max_cache_size = 5
            self.shadow_update_frequency = 2  # Update every 2 frames
        else:  # high
            self.shadow_system.max_cache_size = 8
            self.shadow_update_frequency = 1  # Update every frame
        
        # Add only essential shadow casters for better performance
        self.add_essential_shadow_casters()
        
        # Setup lights
        self.setup_lights()

    def add_essential_shadow_casters(self):
        &quot;&quot;&quot;Add only the most important shadow casters for performance&quot;&quot;&quot;
        # Clear existing shadow casters first
        self.shadow_system.clear_shadow_casters()
        
        # Add trees as shadow casters (most visible)
        for tree in self.trees[:15]:  # Limit to 15 trees for performance
            tree_caster = self.create_tree_shadow_caster(tree)
            self.shadow_system.shadow_casters.append(tree_caster)
            
        # Add rocks as shadow casters
        for rock in self.rocks[:15]:  # Limit to 15 rocks for performance
            rock_caster = self.create_rock_shadow_caster(rock)
            self.shadow_system.shadow_casters.append(rock_caster)
        
        # Add buildings as shadow casters
        if self.market_stall:
            market_caster = self.create_building_shadow_caster(self.market_stall)
            self.shadow_system.shadow_casters.append(market_caster)
        
        if self.seed_shop:
            shop_caster = self.create_building_shadow_caster(self.seed_shop)
            self.shadow_system.shadow_casters.append(shop_caster)

    def setup_lights(self):
        &quot;&quot;&quot;Setup optimized lighting system&quot;&quot;&quot;
        # Main directional light (sun/moon)
        self.sun_light = self.shadow_system.add_light(
            self.world_size[0] // 2,
            -300,
            1200,
            (255, 255, 200),
            intensity=0.8
        )
        
        # Player light (simple, small radius for performance)
        self.player_light = self.shadow_system.add_light(
            self.player[&#x27;position&#x27;][0],
            self.player[&#x27;position&#x27;][1],
            150,  # Smaller radius for performance
            (255, 220, 180),
            intensity=0.6
        )
        
        # Add some static lights for better illumination
        static_lights = [
            (500, 500, 200, (255, 200, 150), 0.4),
            (1500, 500, 200, (200, 220, 255), 0.4),
            (500, 1500, 200, (200, 255, 200), 0.4),
            (1500, 1500, 200, (255, 200, 255), 0.4)
        ]
        
        for x, y, radius, color, intensity in static_lights:
            self.shadow_system.add_light(x, y, radius, color, intensity)

    def create_tree_shadow_caster(self, tree):
        &quot;&quot;&quot;Create simplified shadow caster for a tree&quot;&quot;&quot;
        x, y = tree[&#x27;position&#x27;]  # World position
        size = tree[&#x27;size&#x27;]
        
        # Simple square shadow caster (better performance than circle)
        half_size = size * 0.3
        vertices = [
            (x - half_size, y - half_size),
            (x + half_size, y - half_size),
            (x + half_size, y + half_size),
            (x - half_size, y + half_size)
        ]
        
        return ShadowCaster(vertices)
    
    def create_rock_shadow_caster(self, rock):
        &quot;&quot;&quot;Create simplified shadow caster for a rock&quot;&quot;&quot;
        x, y = rock[&#x27;position&#x27;]  # World position
        size = rock[&#x27;size&#x27;]
        
        # Simple square shadow caster (better performance than circle)
        half_size = size * 0.3
        vertices = [
            (x - half_size, y - half_size),
            (x + half_size, y - half_size),
            (x + half_size, y + half_size),
            (x - half_size, y + half_size)
        ]
        
        return ShadowCaster(vertices)

    def create_building_shadow_caster(self, building):
        &quot;&quot;&quot;Create shadow caster for building&quot;&quot;&quot;
        x, y = building[&#x27;position&#x27;]  # World position
        size = building[&#x27;size&#x27;]
        
        half_size = size // 2
        vertices = [
            (x - half_size, y - half_size),
            (x + half_size, y - half_size),
            (x + half_size, y + half_size),
            (x - half_size, y + half_size)
        ]
        return ShadowCaster(vertices)

    def update_shadows(self):
        &quot;&quot;&quot;Update shadow system with proper world coordinates&quot;&quot;&quot;
        # Update player light - use world position
        if hasattr(self, &#x27;player&#x27;) and self.player:
            self.player_light.position.x = self.player[&#x27;position&#x27;][0]
            self.player_light.position.y = self.player[&#x27;position&#x27;][1]
        
        # Update sun based on time of day - use world position
        sun_angle = self.game_state[&#x27;day_time&#x27;] * 2 * math.pi
        sun_x = self.world_size[0] // 2 + math.cos(sun_angle) * 1000
        sun_y = self.world_size[1] // 2 + math.sin(sun_angle) * 400 - 400
        
        self.sun_light.position.x = sun_x
        self.sun_light.position.y = sun_y
        
        # Day/night cycle - adjust light properties
        if 0.25 &lt;= self.game_state[&#x27;day_time&#x27;] &lt;= 0.75:
            # Daytime
            self.sun_light.color = (255, 255, 200)
            self.sun_light.intensity = 0.8
            self.player_light.intensity = 0.3  # Dim player light during day
        else:
            # Nighttime
            self.sun_light.color = (150, 180, 255)
            self.sun_light.intensity = 0.2
            self.player_light.intensity = 0.8  # Bright player light at night

    def setup_camera(self):
        &quot;&quot;&quot;Configure camera for top-down mode&quot;&quot;&quot;
        # Reset camera position to player position
        self.camera.position = pygame.math.Vector2(self.player[&#x27;position&#x27;])
        self.camera.target_position = pygame.math.Vector2(self.player[&#x27;position&#x27;])
        
        self.camera.mode = CameraMode.TOPDOWN
        self.camera.smooth_speed = 0.1
        self.camera.lead_factor = 0.2
        
        # Set zoom limits
        self.camera.zoom = 1.0
        self.camera.target_zoom = 1.0
        self.camera.min_zoom = 0.7
        self.camera.max_zoom = 2.0
        
        # Set camera bounds to world size
        world_rect = pygame.Rect(0, 0, self.world_size[0], self.world_size[1])
        self.camera.set_bounds(world_rect)
        
        # Set camera to follow player
        self.camera.set_target({
            &#x27;position&#x27;: self.player[&#x27;position&#x27;],
            &#x27;velocity&#x27;: self.player[&#x27;velocity&#x27;]
        }, CameraMode.TOPDOWN)

    def generate_world(self):
        &quot;&quot;&quot;Generate optimized game world&quot;&quot;&quot;
        grass_dark = (80, 160, 80)
        grass_light = (100, 180, 100)
        
        self.bg_surface = pygame.Surface((self.world_size[0], self.world_size[1]))
        # Generate world tiles
        for x in range(0, self.world_size[0], 100):
            for y in range(0, self.world_size[1], 100):
                grass_color = grass_dark if (x // 100 + y // 100) % 2 == 0 else grass_light
                pygame.draw.rect(self.bg_surface, grass_color, (x, y, 100, 100))
        
        # Create player in center
        self.player = {
            &#x27;position&#x27;: [self.world_size[0] // 2, self.world_size[1] // 2],
            &#x27;velocity&#x27;: [0, 0],
            &#x27;speed&#x27;: 200,
            &#x27;size&#x27;: 20
        }
        
        # Generate trees (fewer for better performance)
        for _ in range(20):
            x = random.randint(100, self.world_size[0] - 100)
            y = random.randint(100, self.world_size[1] - 100)
            self.trees.append({
                &#x27;position&#x27;: [x, y],
                &#x27;size&#x27;: random.randint(30, 50),
                &#x27;health&#x27;: 3,
                &#x27;type&#x27;: &#x27;tree&#x27;
            })
        
        # Generate rocks
        for _ in range(15):
            x = random.randint(100, self.world_size[0] - 100)
            y = random.randint(100, self.world_size[1] - 100)
            self.rocks.append({
                &#x27;position&#x27;: [x, y],
                &#x27;size&#x27;: random.randint(25, 40),
                &#x27;health&#x27;: 4,
                &#x27;type&#x27;: &#x27;rock&#x27;
            })
        
        # Generate farm plots
        plot_start_x = 400
        plot_start_y = 400
        for row in range(4):  # Smaller farm for performance
            for col in range(4):
                x = plot_start_x + col * 80
                y = plot_start_y + row * 80
                self.farm_plots.append({
                    &#x27;position&#x27;: [x, y],
                    &#x27;size&#x27;: 60,
                    &#x27;occupied&#x27;: False,
                    &#x27;crop_type&#x27;: None,
                    &#x27;growth_stage&#x27;: 0,
                    &#x27;growth_timer&#x27;: 0
                })
        
        # Place market and seed shop
        shop_y = self.world_size[1] // 2
        self.market_stall = {
            &#x27;position&#x27;: [self.world_size[0] - 250, shop_y],
            &#x27;size&#x27;: 80
        }
        
        self.seed_shop = {
            &#x27;position&#x27;: [self.world_size[0] - 450, shop_y],
            &#x27;size&#x27;: 80
        }

    def setup_parallax(self):
        &quot;&quot;&quot;Setup optimized parallax background&quot;&quot;&quot;
        self.camera.clear_parallax_layers()
        
        # Only use one parallax layer for performance
        sky_surface = self.create_sky_surface()
        self.camera.add_parallax_layer(sky_surface, 0.1, tile_mode=True)
        self.camera.enable_parallax(True)

    def create_sky_surface(self):
        &quot;&quot;&quot;Create simple sky background&quot;&quot;&quot;
        surface = pygame.Surface((800, 600))
        # Simple solid color sky (better performance than gradient)
        surface.fill((70, 70, 120))
        return surface

    def setup_ui(self):
        &quot;&quot;&quot;Setup user interface&quot;&quot;&quot;
        screen_width, screen_height = self.engine.width, self.engine.height
        toolbar_height = 100  # Smaller toolbar
        toolbar_y = screen_height - toolbar_height
        
        # Simple toolbar background
        toolbar_bg = UiFrame(0, toolbar_y, screen_width, toolbar_height)
        self.add_ui_element(toolbar_bg)
        
        # Money display
        self.money_display = TextLabel(20, toolbar_y + 15, f&quot;Money: ${self.game_state[&#x27;money&#x27;]}&quot;, 20, (255, 215, 0))
        self.add_ui_element(self.money_display)
        
        # Inventory display (simplified)
        self.inventory_display = TextLabel(20, toolbar_y + 45, &quot;Inventory: &quot;, 16, (200, 230, 255))
        self.add_ui_element(self.inventory_display)
        
        # Time display
        self.time_display = TextLabel(screen_width - 200, toolbar_y + 15, f&quot;Day {self.game_state[&#x27;day_count&#x27;]}&quot;, 16, (255, 200, 150))
        self.add_ui_element(self.time_display)
        
        # Shadow toggle button
        self.shadow_toggle = Button(screen_width - 200, toolbar_y + 45, 120, 30, &quot;Shadows: ON&quot;)
        self.shadow_toggle.set_on_click(self.toggle_shadows)
        self.add_ui_element(self.shadow_toggle)
        
        # Update initial selection
        self.select_tool(&#x27;axe&#x27;)

    def toggle_shadows(self):
        &quot;&quot;&quot;Toggle shadows on/off&quot;&quot;&quot;
        self.shadows_enabled = not self.shadows_enabled
        self.shadow_toggle.set_text(f&quot;Shadows: {&#x27;ON&#x27; if self.shadows_enabled else &#x27;OFF&#x27;}&quot;)
        print(f&quot;Shadows {&#x27;enabled&#x27; if self.shadows_enabled else &#x27;disabled&#x27;}&quot;)

    def select_tool(self, tool):
        &quot;&quot;&quot;Select tool&quot;&quot;&quot;
        self.game_state[&#x27;selected_tool&#x27;] = tool

    def handle_key_press(self, event):
        &quot;&quot;&quot;Handle key presses&quot;&quot;&quot;
        if event.key == pygame.K_F1:
            self.toggle_shadows()
        elif event.key == pygame.K_1:
            self.select_tool(&#x27;axe&#x27;)
        elif event.key == pygame.K_2:
            self.select_tool(&#x27;pickaxe&#x27;)
        elif event.key == pygame.K_3:
            self.select_tool(&#x27;scythe&#x27;)
        elif event.key == pygame.K_4:
            self.select_tool(&#x27;seeds&#x27;)
        elif event.key == pygame.K_q and self.game_state[&#x27;selected_tool&#x27;] == &#x27;seeds&#x27;:
            self.game_state[&#x27;selected_seed&#x27;] = &#x27;wheat&#x27;
        elif event.key == pygame.K_e and self.game_state[&#x27;selected_tool&#x27;] == &#x27;seeds&#x27;:
            self.game_state[&#x27;selected_seed&#x27;] = &#x27;corn&#x27;

    def get_interaction_distance(self):
        &quot;&quot;&quot;Get maximum interaction distance&quot;&quot;&quot;
        return 80

    def update_player_movement(self, dt):
        &quot;&quot;&quot;Update player movement&quot;&quot;&quot;
        keys = pygame.key.get_pressed()
        
        # Reset velocity
        self.player[&#x27;velocity&#x27;] = [0, 0]
        
        # Movement input
        if keys[pygame.K_w]:
            self.player[&#x27;velocity&#x27;][1] = -1
        if keys[pygame.K_s]:
            self.player[&#x27;velocity&#x27;][1] = 1
        if keys[pygame.K_a]:
            self.player[&#x27;velocity&#x27;][0] = -1
        if keys[pygame.K_d]:
            self.player[&#x27;velocity&#x27;][0] = 1
        
        # Mouse wheel zoom
        if self.engine.mouse_wheel != 0:
            zoom_speed = 0.05
            new_zoom = self.camera.zoom + (self.engine.mouse_wheel * zoom_speed)
            new_zoom = max(self.camera.min_zoom, min(self.camera.max_zoom, new_zoom))
            self.camera.set_zoom(new_zoom, smooth=True)
        
        # Normalize diagonal movement
        if self.player[&#x27;velocity&#x27;][0] != 0 and self.player[&#x27;velocity&#x27;][1] != 0:
            self.player[&#x27;velocity&#x27;][0] *= 0.7071
            self.player[&#x27;velocity&#x27;][1] *= 0.7071
        
        # Apply movement
        self.player[&#x27;position&#x27;][0] += self.player[&#x27;velocity&#x27;][0] * self.player[&#x27;speed&#x27;] * dt
        self.player[&#x27;position&#x27;][1] += self.player[&#x27;velocity&#x27;][1] * self.player[&#x27;speed&#x27;] * dt
        
        # Keep player in bounds
        self.player[&#x27;position&#x27;][0] = max(self.player[&#x27;size&#x27;], min(self.world_size[0] - self.player[&#x27;size&#x27;], self.player[&#x27;position&#x27;][0]))
        self.player[&#x27;position&#x27;][1] = max(self.player[&#x27;size&#x27;], min(self.world_size[1] - self.player[&#x27;size&#x27;], self.player[&#x27;position&#x27;][1]))
        
        # Update camera target
        self.camera.set_target({
            &#x27;position&#x27;: self.player[&#x27;position&#x27;],
            &#x27;velocity&#x27;: self.player[&#x27;velocity&#x27;]
        }, CameraMode.TOPDOWN)

    def handle_interaction(self):
        &quot;&quot;&quot;Handle player interactions with world&quot;&quot;&quot;
        if self.engine.input_state.mouse_buttons_pressed.left:
            tool = self.game_state[&#x27;selected_tool&#x27;]
            ppos = self.player[&#x27;position&#x27;]
            mpos = self.camera.screen_to_world(self.engine.mouse_pos)
            
            if tool == &#x27;axe&#x27;:
                self.chop_tree(ppos, mpos)
            elif tool == &#x27;pickaxe&#x27;:
                self.mine_rock(ppos, mpos)
            elif tool == &#x27;scythe&#x27;:
                self.harvest_crop(ppos, mpos)
            elif tool == &#x27;seeds&#x27;:
                self.plant_seed(ppos, mpos)
            
            # Shop interactions
            self.interact_with_market(ppos, mpos)

    def chop_tree(self, position, mouse_pos):
        &quot;&quot;&quot;Chop nearby tree&quot;&quot;&quot;
        interaction_distance = self.get_interaction_distance()
        
        for tree in self.trees[:]:
            dis = distance(tree[&#x27;position&#x27;], position)
            mdis = distance(tree[&#x27;position&#x27;], mouse_pos)
            
            if dis &lt; interaction_distance and mdis &lt; tree[&#x27;size&#x27;] + 20:
                tree[&#x27;health&#x27;] -= 1
                
                if tree[&#x27;health&#x27;] &lt;= 0:
                    self.trees.remove(tree)
                    self.game_state[&#x27;inventory&#x27;][&#x27;wood&#x27;] += 2
                    # Remove from shadow system and rebuild
                    self.add_essential_shadow_casters()
                
                break

    def mine_rock(self, position, mouse_pos):
        &quot;&quot;&quot;Mine nearby rock&quot;&quot;&quot;
        interaction_distance = self.get_interaction_distance()
        
        for rock in self.rocks[:]:
            dis = distance(rock[&#x27;position&#x27;], position)
            mdis = distance(rock[&#x27;position&#x27;], mouse_pos)
            
            if dis &lt; interaction_distance and mdis &lt; rock[&#x27;size&#x27;] + 20:
                rock[&#x27;health&#x27;] -= 1
                
                if rock[&#x27;health&#x27;] &lt;= 0:
                    self.rocks.remove(rock)
                    self.game_state[&#x27;inventory&#x27;][&#x27;stone&#x27;] += 2
                
                break

    def plant_seed(self, position, mouse_pos):
        &quot;&quot;&quot;Plant seed in empty plot&quot;&quot;&quot;
        if self.game_state[&#x27;seeds&#x27;][self.game_state[&#x27;selected_seed&#x27;]] &lt;= 0:
            return
            
        interaction_distance = self.get_interaction_distance()
        
        for plot in self.farm_plots:
            dis = distance(plot[&#x27;position&#x27;], position)
            mdis = distance(plot[&#x27;position&#x27;], mouse_pos)
            
            if dis &lt; interaction_distance and mdis &lt; plot[&#x27;size&#x27;] + 20 and not plot[&#x27;occupied&#x27;]:
                plot[&#x27;occupied&#x27;] = True
                plot[&#x27;crop_type&#x27;] = self.game_state[&#x27;selected_seed&#x27;]
                plot[&#x27;growth_stage&#x27;] = 1
                plot[&#x27;growth_timer&#x27;] = 0
                
                self.game_state[&#x27;seeds&#x27;][self.game_state[&#x27;selected_seed&#x27;]] -= 1
                break

    def harvest_crop(self, position, mouse_pos):
        &quot;&quot;&quot;Harvest mature crop&quot;&quot;&quot;
        interaction_distance = self.get_interaction_distance()
        
        for plot in self.farm_plots:
            dis = distance(plot[&#x27;position&#x27;], position)
            mdis = distance(plot[&#x27;position&#x27;], mouse_pos)
            
            if dis &lt; interaction_distance and mdis &lt; plot[&#x27;size&#x27;] + 20 and plot[&#x27;occupied&#x27;] and plot[&#x27;growth_stage&#x27;] == 3:
                crop_type = plot[&#x27;crop_type&#x27;]
                self.game_state[&#x27;inventory&#x27;][crop_type] += 3
                
                # Reset plot
                plot[&#x27;occupied&#x27;] = False
                plot[&#x27;crop_type&#x27;] = None
                plot[&#x27;growth_stage&#x27;] = 0
                plot[&#x27;growth_timer&#x27;] = 0
                break

    def interact_with_market(self, position, mouse_pos):
        &quot;&quot;&quot;Sell resources at market&quot;&quot;&quot;
        if not self.market_stall:
            return
        
        dis = distance(self.market_stall[&#x27;position&#x27;], position)
        mdis = distance(self.market_stall[&#x27;position&#x27;], mouse_pos)
        interaction_distance = self.get_interaction_distance()
        
        if dis &lt; interaction_distance and mdis &lt; self.market_stall[&#x27;size&#x27;] + 20:
            # Selling prices
            prices = {
                &#x27;wood&#x27;: 5,
                &#x27;stone&#x27;: 8,
                &#x27;wheat&#x27;: 12,
                &#x27;corn&#x27;: 15
            }
            
            # Sell everything
            total_sale = 0
            for item, quantity in self.game_state[&#x27;inventory&#x27;].items():
                if quantity &gt; 0:
                    total_sale += quantity * prices[item]
                    self.game_state[&#x27;inventory&#x27;][item] = 0
            
            if total_sale &gt; 0:
                self.game_state[&#x27;money&#x27;] += total_sale

    def update_crops(self, dt):
        &quot;&quot;&quot;Update crop growth&quot;&quot;&quot;
        for plot in self.farm_plots:
            if plot[&#x27;occupied&#x27;]:
                plot[&#x27;growth_timer&#x27;] += dt
                
                # Grow every 5 seconds
                if plot[&#x27;growth_timer&#x27;] &gt;= 5:
                    plot[&#x27;growth_stage&#x27;] = min(3, plot[&#x27;growth_stage&#x27;] + 1)
                    plot[&#x27;growth_timer&#x27;] = 0

    def update_time(self, dt):
        &quot;&quot;&quot;Update day/night cycle&quot;&quot;&quot;
        self.game_state[&#x27;day_time&#x27;] += dt / 120  # 2 minutes per full day
        
        if self.game_state[&#x27;day_time&#x27;] &gt;= 1:
            self.game_state[&#x27;day_time&#x27;] = 0
            self.game_state[&#x27;day_count&#x27;] += 1

    def update_ui(self):
        &quot;&quot;&quot;Update UI displays&quot;&quot;&quot;
        # Money
        self.money_display.set_text(f&quot;Money: ${self.game_state[&#x27;money&#x27;]}&quot;)
        
        # Inventory
        inv_text = &quot;Inventory: &quot;
        for item, quantity in self.game_state[&#x27;inventory&#x27;].items():
            if quantity &gt; 0:
                inv_text += f&quot;{item}:{quantity} &quot;
        self.inventory_display.set_text(inv_text)
        
        # Time
        time_of_day = &quot;Morning&quot; if self.game_state[&#x27;day_time&#x27;] &lt; 0.25 else \
                     &quot;Noon&quot; if self.game_state[&#x27;day_time&#x27;] &lt; 0.5 else \
                     &quot;Evening&quot; if self.game_state[&#x27;day_time&#x27;] &lt; 0.75 else &quot;Night&quot;
        self.time_display.set_text(f&quot;Day {self.game_state[&#x27;day_count&#x27;]} - {time_of_day}&quot;)

    def update(self, dt):
        &quot;&quot;&quot;Update game logic&quot;&quot;&quot;
        # Update player movement
        self.update_player_movement(dt)
        
        # Update camera
        self.camera.update(dt)
        
        # Update shadow system (less frequently for performance)
        static_frame_count = getattr(self, &#x27;_static_frame_count&#x27;, 0)
        self._static_frame_count = static_frame_count + 1
        
        if self.shadows_enabled and static_frame_count % 2 == 0:  # Update every 2 frames
            self.update_shadows()
        
        # Update interactions
        self.handle_interaction()
        
        # Update crops
        self.update_crops(dt)
        
        # Update time
        self.update_time(dt)
        
        # Update UI
        self.update_ui()

    def apply_camera_offset(self, position):
        &quot;&quot;&quot;Apply camera offset to convert world coordinates to screen coordinates&quot;&quot;&quot;
        if isinstance(position, (list, tuple)):
            screen_pos = self.camera.world_to_screen(position)
            return (screen_pos.x, screen_pos.y)
        return position

    def get_ambient_color(self):
        &quot;&quot;&quot;Get ambient color based on time&quot;&quot;&quot;
        time_of_day = self.game_state[&#x27;day_time&#x27;]
        if time_of_day &lt; 0.25: return (120, 140, 180)
        elif time_of_day &lt; 0.5: return (150, 170, 200)
        elif time_of_day &lt; 0.75: return (180, 150, 140)
        else: return (80, 90, 120)

    def render_world(self, renderer):
        &quot;&quot;&quot;Render the game world with proper coordinate conversion&quot;&quot;&quot;
        # Render parallax background
        self.camera.render_parallax(renderer)
        
        # Render base terrain
        screen_pos = self.apply_camera_offset((0, 0))
        renderer.blit(self.bg_surface, screen_pos)
        
        # Render farm plots
        for plot in self.farm_plots:
            screen_x, screen_y = self.apply_camera_offset(plot[&#x27;position&#x27;])
            size = plot[&#x27;size&#x27;] * self.camera.zoom
            
            # Plot color based on state
            if plot[&#x27;occupied&#x27;]:
                if plot[&#x27;growth_stage&#x27;] == 1:
                    plot_color = (180, 160, 120)
                elif plot[&#x27;growth_stage&#x27;] == 2:
                    plot_color = (140, 180, 100)
                else:
                    plot_color = (100, 160, 80)
            else:
                plot_color = (120, 80, 40)
            
            renderer.draw_rect(screen_x - size//2, screen_y - size//2, size, size, (80, 50, 20), fill=False)
            renderer.draw_rect(screen_x - size//2, screen_y - size//2, size, size, plot_color)
        
        # Render trees
        for tree in self.trees:
            screen_x, screen_y = self.apply_camera_offset(tree[&#x27;position&#x27;])
            size = tree[&#x27;size&#x27;] * self.camera.zoom
            
            # Trunk
            trunk_color = (90, 60, 30)
            renderer.draw_rect(screen_x - 5, screen_y - size//2, 10, size//2, trunk_color)
            # Canopy
            canopy_color = (40, 120, 40)
            renderer.draw_circle(screen_x, screen_y - size//4, size//2, canopy_color)
        
        # Render rocks
        for rock in self.rocks:
            screen_x, screen_y = self.apply_camera_offset(rock[&#x27;position&#x27;])
            size = rock[&#x27;size&#x27;] * self.camera.zoom
            rock_color = (100, 100, 120)
            renderer.draw_circle(screen_x, screen_y, size//2, rock_color)
        
        # Render player
        screen_x, screen_y = self.apply_camera_offset(self.player[&#x27;position&#x27;])
        size = self.player[&#x27;size&#x27;] * self.camera.zoom
        
        renderer.draw_circle(screen_x, screen_y, size//2, (170, 150, 240))

    def render(self, renderer):
        &quot;&quot;&quot;Render the game with optimized shadows&quot;&quot;&quot;
        
        # Apply ambient color based on time of day
        ambient_color = self.get_ambient_color()
        renderer.get_surface().fill(ambient_color)
        
        # Render World
        self.render_world(renderer)
        
        # Render market
        if self.market_stall:
            screen_x, screen_y = self.apply_camera_offset(self.market_stall[&#x27;position&#x27;])
            size = self.market_stall[&#x27;size&#x27;] * self.camera.zoom
            market_color = (200, 160, 60)
            renderer.draw_rect(screen_x - size//2, screen_y - size//2, size, size, market_color)
            renderer.draw_text(&quot;Market&quot;, screen_x - size//2, screen_y - size//2, (255, 255, 255), pygame.font.SysFont(&quot;Arial&quot;, 20))
        
        # Render seed shop
        if self.seed_shop:
            screen_x, screen_y = self.apply_camera_offset(self.seed_shop[&#x27;position&#x27;])
            size = self.seed_shop[&#x27;size&#x27;] * self.camera.zoom
            shop_color = (120, 180, 100)
            renderer.draw_rect(screen_x - size//2, screen_y - size//2, size, size, shop_color)
            renderer.draw_text(&quot;Seed Shop&quot;, screen_x - size//2, screen_y - size//2, (255, 255, 255), pygame.font.SysFont(&quot;Arial&quot;, 20))
        
        # Render shadows only if enabled
        if self.shadows_enabled:
            try:
                # Use camera base position (without shake) for shadow calculation
                shadow_surface = self.shadow_system.render(self.camera.base_position, renderer)
                if shadow_surface and isinstance(shadow_surface, pygame.Surface):
                    # Apply shadows with proper blending
                    renderer.blit(shadow_surface, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
            except Exception as e:
                # If shadows cause issues, disable them
                print(f&quot;Shadow rendering error: {e}&quot;)
                import traceback
                traceback.print_exc()
                self.shadows_enabled = False
                self.shadow_toggle.set_text(&quot;Shadows: OFF&quot;)

def main():
    &quot;&quot;&quot;Main function&quot;&quot;&quot;
    engine = LunaEngine(&quot;Top-Down Farming Game&quot;, 1024, 768)
    engine.fps = 60
    
    # Register event handlers
    @engine.on_event(pygame.KEYDOWN)
    def on_key_press(event):
        if engine.current_scene and hasattr(engine.current_scene, &#x27;handle_key_press&#x27;):
            engine.current_scene.handle_key_press(event)
    
    engine.add_scene(&quot;game&quot;, TopDownFarmingGame)
    engine.set_scene(&quot;game&quot;)
    
    print(&quot;=== Top-Down Farming Game with Optimized Shadows ===&quot;)
    print(&quot;Controls:&quot;)
    print(&quot;WASD - Move player&quot;)
    print(&quot;Mouse Click - Interact with objects&quot;) 
    print(&quot;1-4 - Select tools&quot;)
    print(&quot;Q/E - Select seeds (when seeds tool is active)&quot;)
    print(&quot;F1 - Toggle shadows on/off&quot;)
    print(&quot;\nPress F1 to disable shadows if performance is poor&quot;)
    
    engine.run()

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
                    </div>
                </div>
            </div>
            <div class="col-lg-4">
                <div class="card shadow-sm sticky-top" style="top: 20px;">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0"><i class="bi bi-info-circle me-2"></i>About This Example</h5>
                    </div>
                    <div class="card-body">
                        <p>topdown_farming_demo.py - Top-Down Farming Game Demo with Optimized Shadows</p>
                        <hr>
                        <div class="d-grid gap-2">
                            <a href="topdown_farming_demo.py" download class="btn btn-outline-primary">
                                <i class="bi bi-download me-2"></i>Download Python File
                            </a>
                            <a href="index.html" class="btn btn-outline-secondary">
                                <i class="bi bi-arrow-left me-2"></i>Back to Examples Hub
                            </a>
                            <a href="../quick-start.html" class="btn btn-outline-success">
                                <i class="bi bi-play-circle me-2"></i>Quick Start Guide
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="footer-section">
        <div class="container">
            <div class="row">
                <div class="col-md-6">
                    <h5><i class="bi bi-moon-stars-fill me-2"></i>LunaEngine</h5>
                    <p class="text-white-50">2D Game Framework for Python</p>
                </div>
                <div class="col-md-6 text-end">
                    <p class="text-white-50">
                        <i class="bi bi-lightning-charge me-1"></i>
                        Documentation generated on 2026-01-20 14:14
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="theme.js"></script>
    
    <script>
    // Universal search handler
    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById('moduleSearch');
        const searchIcon = document.querySelector('.input-group-text');
        
        if (searchInput && searchIcon) {
            const performSearch = () => {
                const searchTerm = searchInput.value.trim();
                if (searchTerm) {
                    const currentPath = window.location.pathname;
                    let searchPath = 'search.html';
                    
                    // Adjust path based on current location
                    if (currentPath.split('/').filter(Boolean).length > 2) {
                        searchPath = '../search.html';
                    }
                    
                    window.location.href = `${searchPath}?q=${encodeURIComponent(searchTerm)}`;
                }
            };
            
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); 
                    e.stopPropagation();
                    performSearch();
                    return false;
                }
            });
            
            searchIcon.addEventListener('click', performSearch);
            
            const form = searchInput.closest('form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    performSearch();
                    return false;
                });
            }
        }
    });
    </script>
    
    
</body>
</html>