<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Demo - LunaEngine Examples</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="../theme.css" rel="stylesheet">
</head>
<body>
    
    <nav class="navbar navbar-expand-lg navbar-light sticky-top">
        <div class="container">
            <a class="navbar-brand fw-bold" href="../index.html" id="navbar-logo-link">
                <i class="bi bi-moon-stars-fill me-2"></i>
                LunaEngine
            </a>
            <div class="d-flex align-items-center">
                <div class="input-group me-3">
                    <input type="text" id="moduleSearch" class="form-control" placeholder="Search functions, classes, methods...">
                    <span class="input-group-text" id="searchIcon"><i class="bi bi-search"></i></span>
                </div>
                
                <button class="btn btn-outline-secondary theme-toggle">
                    <span class="theme-icon">ðŸŒ™</span>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container mt-5">
        <nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../index.html">Home</a></li><li class="breadcrumb-item"><a href="index.html">Examples Hub</a></li><li class="breadcrumb-item active">Multiplayer Demo</li></ol></nav>
        
        <div class="row">
            <div class="col-lg-8">
                <h1 class="mb-3"><i class="bi bi-code-slash me-2"></i>Multiplayer Demo</h1>
                <div class="card mb-4 shadow-sm">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0"><i class="bi bi-file-earmark-code me-2"></i>multiplayer_demo.py</h5>
                    </div>
                    <div class="card-body">
                        <pre><code class="language-python">from lunaengine.core import LunaEngine, Scene
from lunaengine.backend.network import NetworkClient, NetworkHost, NetworkServer
from lunaengine.backend.network import MessageType, NetworkMessage, UserType
from lunaengine.ui import *
import pygame as pg
import time
import random

class NetworkInfo:
    def __init__(self):
        self.host = None
        self.server = None
        self.client = None
        self.is_connected = False
        self.is_host = False
        self.messages = []
        self.player_id = None

class MainScene(Scene):
    def on_enter(self, previous_scene = None):
        print(&quot;=== Multiplayer Demo ===&quot;)
        print(&quot;1. For host: Check &#x27;Is Host&#x27;, click &#x27;Start Host&#x27;&quot;)
        print(&quot;2. For client: Uncheck &#x27;Is Host&#x27;, enter host IP, click &#x27;Connect&#x27;&quot;)
        print(&quot;3. Click &#x27;Play&#x27; to enter game&quot;)
        return super().on_enter(previous_scene)
    
    def on_exit(self, next_scene = None):
        return super().on_exit(next_scene)
    
    def __init__(self, engine: LunaEngine):
        super().__init__(engine)
        self.network_info = None
        self.connection_status = &quot;Not connected&quot;
        self.setup_ui()
        
    def setup_ui(self):
        screen_width, screen_height = self.engine.width, self.engine.height
        
        # Title
        self.add_ui_element(TextLabel(512, 30, &quot;LunaEngine - Multiplayer Demo&quot;, 36, (255, 255, 255), root_point=(0.5, 0)))
        
        # Connection Frame
        self.frame = UiFrame(40, 150, 600, 400, root_point=(0, 0))
        self.frame.set_background_color((60, 60, 80))
        self.add_ui_element(self.frame)
        
        # Network Settings
        self.frame.add_child(TextLabel(50, 30, &quot;Network Settings&quot;, 28, (255, 255, 200), root_point=(0, 0)))
        
        # Host/IP Input
        self.frame.add_child(TextLabel(50, 80, &quot;Host / IP:&quot;, 20, (200, 230, 255), root_point=(0, 0)))
        self.host_input = TextBox(150, 75, 200, 35, &#x27;127.0.0.1&#x27;, 18, root_point=(0, 0))
        self.host_input.set_text(&quot;127.0.0.1&quot;)
        self.frame.add_child(self.host_input)
        
        # Port Input
        self.frame.add_child(TextLabel(50, 130, &quot;Port:&quot;, 20, (200, 230, 255), root_point=(0, 0)))
        self.port_input = NumberSelector(150, 125, 120, 35, 1024, 65535, 4723, 4, 4, root_point=(0, 0))
        self.frame.add_child(self.port_input)
        
        # Is Host Checkbox
        self.is_host_check = Checkbox(50, 180, 30, 30, False, &quot;Run as Host (Server + Client)&quot;)
        self.frame.add_child(self.is_host_check)
        
        # Connection Status
        self.status_label = TextLabel(300, 225, &quot;Status: Not connected&quot;, 20, (255, 100, 100), root_point=(0, 0))
        self.frame.add_child(self.status_label)
        
        # Action Buttons Frame
        button_frame = UiFrame(screen_width-40, 150, 240, 355, root_point=(1, 0))
        button_frame.set_background_color((80, 80, 100))
        self.add_ui_element(button_frame)
        
        # Start Host Button
        self.start_host_btn = Button(120, 20, 200, 30, &quot;Start Host&quot;, 24, root_point=(0.5, 0))
        self.start_host_btn.set_on_click(self.start_host)
        button_frame.add_child(self.start_host_btn)
        
        # Connect Button
        self.connect_btn = Button(120, 65, 200, 30, &quot;Connect&quot;, 24, root_point=(0.5, 0))
        self.connect_btn.set_on_click(self.connect_as_client)
        button_frame.add_child(self.connect_btn)
        
        self.play_btn = Button(120, 110, 200, 40, &quot;Play&quot;, 32, root_point=(0.5, 0))
        self.play_btn.set_on_click(self.go_to_game)
        self.play_btn.set_enabled(False)
        button_frame.add_child(self.play_btn)
        
        # Exit Button
        self.exit_btn = Button(120, 160, 200, 35, &quot;Exit&quot;, 24, root_point=(0.5, 0))
        self.exit_btn.set_on_click(lambda: setattr(self.engine, &#x27;running&#x27;, False))
        button_frame.add_child(self.exit_btn)
        
        # Instructions
        instructions = [
            &quot;INSTRUCTIONS:&quot;,
            &quot;1. To host: Check &#x27;Run as Host&#x27;, click &#x27;Start Host&#x27;&quot;,
            &quot;2. To join: Enter host IP, click &#x27;Connect&#x27;&quot;,
            &quot;3. When connected, click &#x27;Play&#x27; to start game&quot;,
            &quot;&quot;,
            &quot;Default host IP: 127.0.0.1 (localhost)&quot;,
            &quot;Default port: 4723&quot;
        ]
        
        for i, text in enumerate(instructions):
            color = (255, 255, 200) if i == 0 else (180, 230, 255)
            self.add_ui_element(TextLabel(20, 600 + i * 25, text, 16, color, root_point=(0, 0)))
    
    def start_host(self):
        &quot;&quot;&quot;Start as host (server + client)&quot;&quot;&quot;
        host = self.host_input.get_text()
        port = self.port_input.get_value()
        
        print(f&quot;Starting host on {host}:{port}...&quot;)
        self.status_label.set_text(&quot;Starting host...&quot;)
        self.status_label.color = (255, 200, 100)
        
        # Create network info
        self.network_info = NetworkInfo()
        self.network_info.is_host = True
        
        try:
            # Start host
            self.network_info.host = NetworkHost(host=host, port=port)
            if self.network_info.host.start():
                self.network_info.is_connected = True
                self.network_info.player_id = self.network_info.host.client.client_id
                
                print(f&quot;Host started successfully! Player ID: {self.network_info.player_id}&quot;)
                self.status_label.set_text(f&quot;Host running on {host}:{port}&quot;)
                self.status_label.color = (100, 255, 100)
                
                # Setup message handler for host
                def handle_host_message(msg):
                    if msg and len(msg) &gt; 0:
                        source = msg[0]
                        if source == &quot;client&quot;:
                            # Message from server to our client component
                            message = msg[1]
                            if message.message_type == MessageType.DATA:
                                print(f&quot;Host client received: {message.payload}&quot;)
                                # Forward to game scene if it exists
                                if hasattr(self, &#x27;network_info&#x27;):
                                    self.network_info.messages.append(message)
                        elif source == &quot;server&quot;:
                            # Message from a client to our server component
                            client_id, message = msg[1], msg[2]
                            if message.message_type == MessageType.DATA:
                                print(f&quot;Host server received from {client_id}: {message.payload}&quot;)
                                # Broadcast to all other clients (including ourselves)
                                if self.network_info.host:
                                    # Create broadcast message
                                    broadcast_data = {
                                        &quot;message_id&quot;: message.message_id,
                                        &quot;message_type&quot;: MessageType.DATA.value,
                                        &quot;sender_id&quot;: client_id,
                                        &quot;sender_type&quot;: message.sender_type.value,
                                        &quot;timestamp&quot;: message.timestamp,
                                        &quot;payload&quot;: message.payload
                                    }
                                    # Broadcast to all except sender
                                    self.network_info.host.server.broadcast(broadcast_data, exclude=[client_id])
                                    # Also store for our own client
                                    if hasattr(self, &#x27;network_info&#x27;):
                                        self.network_info.messages.append(message)
                
                # Store in engine for other scenes to access
                self.engine.network_info = self.network_info
                
                # Enable play button
                self.play_btn.set_enabled(True)
                self.start_host_btn.set_enabled(False)
                self.connect_btn.set_enabled(False)
                
                print(&quot;Host setup complete&quot;)
            else:
                self.status_label.set_text(&quot;Failed to start host&quot;)
                self.status_label.color = (255, 100, 100)
                self.network_info = None
                
        except Exception as e:
            print(f&quot;Error starting host: {e}&quot;)
            import traceback
            traceback.print_exc()
            self.status_label.set_text(f&quot;Error: {str(e)}&quot;)
            self.status_label.color = (255, 100, 100)
            self.network_info = None
    
    def connect_as_client(self):
        &quot;&quot;&quot;Connect to server as client&quot;&quot;&quot;
        host = self.host_input.get_text()
        port = self.port_input.get_value()
        
        print(f&quot;Connecting to {host}:{port}...&quot;)
        self.status_label.set_text(f&quot;Connecting to {host}:{port}...&quot;)
        self.status_label.color = (255, 200, 100)
        
        # Create network info
        self.network_info = NetworkInfo()
        self.network_info.is_host = False
        
        try:
            # Connect as client
            self.network_info.client = NetworkClient()
            if self.network_info.client.connect(host, port, timeout=5):
                self.network_info.is_connected = True
                self.network_info.player_id = self.network_info.client.client_id
                
                print(f&quot;Connected to server! Player ID: {self.network_info.player_id}&quot;)
                self.status_label.set_text(f&quot;Connected to {host}:{port}&quot;)
                self.status_label.color = (100, 255, 100)
                
                # Setup message handler for client
                def handle_client_message(msg: NetworkMessage):
                    print(f&quot;Client received: {msg.message_type} - {msg.payload}&quot;)
                    self.handle_network_message(msg)
                
                # Register callback for data messages
                self.network_info.client.register_callback(MessageType.DATA, handle_client_message)
                
                # Store in engine
                self.engine.network_info = self.network_info
                
                # Enable play button
                self.play_btn.set_enabled(True)
                self.start_host_btn.set_enabled(False)
                self.connect_btn.set_enabled(False)
                
                print(&quot;Client setup complete&quot;)
            else:
                self.status_label.set_text(&quot;Connection failed&quot;)
                self.status_label.color = (255, 100, 100)
                self.network_info = None
                
        except Exception as e:
            print(f&quot;Connection error: {e}&quot;)
            self.status_label.set_text(f&quot;Error: {str(e)}&quot;)
            self.status_label.color = (255, 100, 100)
            self.network_info = None
    
    def handle_network_message(self, message, sender_id=None):
        &quot;&quot;&quot;Handle incoming network messages&quot;&quot;&quot;
        if isinstance(message, NetworkMessage):
            print(f&quot;Received: {message.message_type} from {sender_id or message.sender_id}&quot;)
            if hasattr(self, &#x27;network_info&#x27;):
                self.network_info.messages.append(message)
    
    def go_to_game(self):
        &quot;&quot;&quot;Go to the game scene&quot;&quot;&quot;
        if self.network_info and self.network_info.is_connected:
            print(&quot;Going to game scene...&quot;)
            self.engine.set_scene(&quot;InGame&quot;)
        else:
            self.status_label.set_text(&quot;Not connected!&quot;)
            self.status_label.color = (255, 100, 100)
    
    def render(self, renderer):
        renderer.fill_screen(ThemeManager.get_color(&#x27;background&#x27;))
    
    def update(self, dt):
        # Update connection status display
        if self.network_info and self.network_info.is_connected:
            if self.network_info.is_host:
                if self.network_info.host:
                    player_count = self.network_info.host.get_client_count()
                    self.status_label.set_text(f&quot;Host: {player_count} clients connected&quot;)
                else:
                    self.status_label.set_text(&quot;Host running&quot;)
            else:
                if self.network_info.client and self.network_info.client.connected:
                    self.status_label.set_text(&quot;Connected to server&quot;)
                else:
                    self.status_label.set_text(&quot;Disconnected&quot;)
        
        return super().update(dt)

class Player:
    def __init__(self, x, y, player_id, name=&quot;Player&quot;, color=(255, 255, 255)):
        self.x = x
        self.y = y
        self.id = player_id
        self.name = name
        self.width = 40
        self.height = 40
        self.color = color
        self.velocity = [0, 0]
        self.speed = 250
        self.last_update = 0

class InGameScene(Scene):
    def __init__(self, engine: LunaEngine):
        super().__init__(engine)
        self.players = {}  # player_id: Player
        self.local_player = None
        self.chat_messages = []  # Store chat messages
        self.setup_ui()
        self.network_update_timer = 0
        self.network_update_interval = 0.05  # 20 updates per second
        self.last_player_update = 0
        
    def on_enter(self, previous_scene=None):
        print(&quot;Entering game scene...&quot;)
        
        # Get network info from engine
        if hasattr(self.engine, &#x27;network_info&#x27;):
            self.network_info = self.engine.network_info
            
            if self.network_info and self.network_info.is_connected:
                # Create local player
                player_name = f&quot;Player_{self.network_info.player_id[:4]}&quot;
                player_color = (
                    random.randint(100, 255),
                    random.randint(100, 255),
                    random.randint(100, 255)
                )
                
                self.local_player = Player(
                    x=512, y=360,
                    player_id=self.network_info.player_id,
                    name=player_name,
                    color=player_color
                )
                self.players[self.network_info.player_id] = self.local_player
                
                # Send player join message
                self.send_player_join()
                print(f&quot;Local player created: {player_name}&quot;)
                
                # If host, send existing players to new clients
                if self.network_info.is_host and self.network_info.host:
                    print(&quot;Host: Will broadcast player list to new clients&quot;)
            else:
                print(&quot;Not connected to network!&quot;)
                self.engine.set_scene(&quot;main&quot;)
        else:
            print(&quot;No network info found!&quot;)
            self.engine.set_scene(&quot;main&quot;)
    
    def on_exit(self, next_scene=None):
        # Send player leave message
        if hasattr(self, &#x27;local_player&#x27;) and self.local_player:
            self.send_player_leave()
        
        # Clear players
        self.players.clear()
        return super().on_exit(next_scene)
    
    def setup_ui(self):
        # Game UI (hidden by default)
        self.ui_frame = UiFrame(512, 300, 400, 375,root_point=(0.5, 0))
        self.ui_frame.set_background_color((60, 60, 80, 200))
        self.ui_frame.add_group(&#x27;game_ui&#x27;)
        self.add_ui_element(self.ui_frame)
        
        # UI Title
        self.ui_frame.add_child(TextLabel(200, 20, &quot;Multiplayer Game&quot;, 28, (255, 255, 200), root_point=(0.5, 0)))
        
        # Player List
        self.player_list_label = TextLabel(20, 60, &quot;Players:&quot;, 22, (200, 230, 255))
        self.ui_frame.add_child(self.player_list_label)
        
        # Chat Display Label
        self.chat_display_label = TextLabel(20, 120, &quot;Chat:&quot;, 22, (200, 230, 255))
        self.ui_frame.add_child(self.chat_display_label)
        
        # Chat Scrolling Frame - FIXED: Proper ScrollingFrame setup
        self.chat_scrolling = ScrollingFrame(200, 150, 340, 100, 340, 200, root_point=(0.5, 0))
        self.chat_scrolling.set_background_color((40, 40, 50, 200))
        self.ui_frame.add_child(self.chat_scrolling)
        
        # Chat Input
        self.chat_input = TextBox(20, 280, 250, 35, &quot;Type message...&quot;, 16)
        self.ui_frame.add_child(self.chat_input)
        
        # Send Chat Button
        self.send_chat_btn = Button(280, 280, 80, 35, &quot;Send&quot;, 16)
        self.send_chat_btn.set_on_click(self.send_chat)
        self.ui_frame.add_child(self.send_chat_btn)
        
        # Disconnect Button
        self.disconnect_btn = Button(200, 320, 120, 40, &quot;Disconnect&quot;, 20, root_point=(0.5, 0))
        self.disconnect_btn.set_on_click(self.disconnect)
        self.ui_frame.add_child(self.disconnect_btn)
        
        # Hide UI by default
        self.ui_visible = False
        self.toggle_element_group(&#x27;game_ui&#x27;, self.ui_visible)
        
        # Add ESC key handler to toggle UI
        @self.engine.on_event(pg.KEYDOWN)
        def on_keydown(event):
            if event.key == pg.K_ESCAPE:
                self.ui_visible = not self.ui_visible
                self.toggle_element_group(&#x27;game_ui&#x27;, self.ui_visible)
            elif event.key == pg.K_RETURN and self.chat_input.has_focus():
                self.send_chat()
    
    def send_player_join(self):
        &quot;&quot;&quot;Send player join message&quot;&quot;&quot;
        if not self.local_player or not hasattr(self, &#x27;network_info&#x27;):
            return
        
        join_data = {
            &#x27;type&#x27;: &#x27;player_join&#x27;,
            &#x27;player_id&#x27;: self.local_player.id,
            &#x27;name&#x27;: self.local_player.name,
            &#x27;position&#x27;: [self.local_player.x, self.local_player.y],
            &#x27;color&#x27;: self.local_player.color
        }
        
        self.send_network_message(join_data)
        print(f&quot;Sent player join: {self.local_player.name}&quot;)
    
    def send_player_leave(self):
        &quot;&quot;&quot;Send player leave message&quot;&quot;&quot;
        if not self.local_player or not hasattr(self, &#x27;network_info&#x27;):
            return
        
        leave_data = {
            &#x27;type&#x27;: &#x27;player_leave&#x27;,
            &#x27;player_id&#x27;: self.local_player.id
        }
        
        self.send_network_message(leave_data)
        print(f&quot;Sent player leave: {self.local_player.name}&quot;)
    
    def send_player_update(self):
        &quot;&quot;&quot;Send player position update&quot;&quot;&quot;
        if not self.local_player or not hasattr(self, &#x27;network_info&#x27;):
            return
        
        # Only send update if position changed significantly
        current_time = time.time()
        if current_time - self.last_player_update &lt; 0.1:  # Limit to 10 updates per second
            return
        
        update_data = {
            &#x27;type&#x27;: &#x27;player_update&#x27;,
            &#x27;player_id&#x27;: self.local_player.id,
            &#x27;position&#x27;: [self.local_player.x, self.local_player.y],
            &#x27;velocity&#x27;: self.local_player.velocity
        }
        
        self.send_network_message(update_data)
        self.last_player_update = current_time
    
    def send_chat(self):
        &quot;&quot;&quot;Send chat message&quot;&quot;&quot;
        message = self.chat_input.get_text().strip()
        if not message or not hasattr(self, &#x27;network_info&#x27;):
            return
        
        chat_data = {
            &#x27;type&#x27;: &#x27;chat&#x27;,
            &#x27;player_id&#x27;: self.local_player.id,
            &#x27;player_name&#x27;: self.local_player.name,
            &#x27;message&#x27;: message,
            &#x27;timestamp&#x27;: time.time()
        }
        
        self.send_network_message(chat_data)
        
        # Add to local chat immediately
        self.add_chat_message(self.local_player.name, message)
        
        # Clear input
        self.chat_input.set_text(&quot;&quot;)
    
    def send_network_message(self, data):
        &quot;&quot;&quot;Send network message based on connection type&quot;&quot;&quot;
        if not hasattr(self, &#x27;network_info&#x27;) or not self.network_info.is_connected:
            return False
        
        try:
            if self.network_info.is_host:
                # As host, send through our client component
                if self.network_info.host and self.network_info.host.client:
                    return self.network_info.host.send_as_host(MessageType.DATA, data)
            else:
                # As client, send directly
                if self.network_info.client and self.network_info.client.connected:
                    return self.network_info.client.send(MessageType.DATA, data)
        except Exception as e:
            print(f&quot;Error sending message: {e}&quot;)
            return False
        
        return False
    
    def process_network_messages(self):
        &quot;&quot;&quot;Process incoming network messages&quot;&quot;&quot;
        if not hasattr(self, &#x27;network_info&#x27;) or not self.network_info.is_connected:
            return
        
        try:
            if self.network_info.is_host:
                # Process host messages
                if self.network_info.host:
                    msg = self.network_info.host.get_message(timeout=0)
                    while msg:
                        source = msg[0]
                        if source == &quot;client&quot;:
                            # Message from server to our client
                            message = msg[1]
                            self.handle_network_message(message)
                        elif source == &quot;server&quot;:
                            # Message from a client to our server
                            client_id, message = msg[1], msg[2]
                            print(f&quot;Host server received from {client_id}: {message.payload}&quot;)
                            
                            # Handle the message locally
                            self.handle_network_message(message, client_id)
                            
                            # If it&#x27;s a player join/update/chat, broadcast to all except sender
                            if message.message_type == MessageType.DATA:
                                data = message.payload
                                if isinstance(data, dict) and data.get(&#x27;type&#x27;) in [&#x27;player_join&#x27;, &#x27;player_update&#x27;, &#x27;chat&#x27;]:
                                    # Don&#x27;t broadcast our own messages back to ourselves
                                    if client_id != self.network_info.player_id:
                                        # Broadcast to all other clients
                                        broadcast_msg = {
                                            &quot;message_id&quot;: message.message_id,
                                            &quot;message_type&quot;: MessageType.DATA.value,
                                            &quot;sender_id&quot;: client_id,
                                            &quot;sender_type&quot;: message.sender_type.value,
                                            &quot;timestamp&quot;: message.timestamp,
                                            &quot;payload&quot;: data
                                        }
                                        self.network_info.host.server.broadcast(broadcast_msg, exclude=[client_id])
                        
                        msg = self.network_info.host.get_message(timeout=0)
            else:
                # Process client messages
                if self.network_info.client:
                    msg = self.network_info.client.get_message(timeout=0)
                    while msg:
                        self.handle_network_message(msg)
                        msg = self.network_info.client.get_message(timeout=0)
        except Exception as e:
            print(f&quot;Error processing messages: {e}&quot;)
    
    def handle_network_message(self, message, sender_id=None):
        &quot;&quot;&quot;Handle a network message&quot;&quot;&quot;
        if not isinstance(message, NetworkMessage) or message.message_type != MessageType.DATA:
            return
        
        data = message.payload
        if not isinstance(data, dict):
            return
        
        msg_type = data.get(&#x27;type&#x27;)
        player_id = data.get(&#x27;player_id&#x27;)
        
        # Handle different message types
        if msg_type == &#x27;player_join&#x27;:
            # New player joined
            if player_id and player_id != self.local_player.id:
                player_name = data.get(&#x27;name&#x27;, f&#x27;Player_{player_id[:4]}&#x27;)
                position = data.get(&#x27;position&#x27;, [512, 360])
                color = data.get(&#x27;color&#x27;, (255, 255, 255))
                
                if player_id not in self.players:
                    self.players[player_id] = Player(
                        x=position[0], y=position[1],
                        player_id=player_id,
                        name=player_name,
                        color=color
                    )
                    
                    self.add_chat_message(&quot;System&quot;, f&quot;{player_name} joined the game&quot;)
                    print(f&quot;Player joined: {player_name}&quot;)
        
        elif msg_type == &#x27;player_leave&#x27;:
            # Player left
            if player_id in self.players:
                player_name = self.players[player_id].name
                del self.players[player_id]
                self.add_chat_message(&quot;System&quot;, f&quot;{player_name} left the game&quot;)
                print(f&quot;Player left: {player_name}&quot;)
        
        elif msg_type == &#x27;player_update&#x27;:
            # Player position update
            if player_id in self.players and player_id != self.local_player.id:
                position = data.get(&#x27;position&#x27;)
                if position:
                    self.players[player_id].x = position[0]
                    self.players[player_id].y = position[1]
                    # Update velocity if provided
                    velocity = data.get(&#x27;velocity&#x27;)
                    if velocity:
                        self.players[player_id].velocity = velocity
        
        elif msg_type == &#x27;chat&#x27;:
            # Chat message
            player_name = data.get(&#x27;player_name&#x27;, f&#x27;Player_{player_id[:4]}&#x27;)
            message_text = data.get(&#x27;message&#x27;, &#x27;&#x27;)
            self.add_chat_message(player_name, message_text)
            print(f&quot;Chat from {player_name}: {message_text}&quot;)
    
    def add_chat_message(self, sender, message):
        &quot;&quot;&quot;Add chat message to ScrollingFrame&quot;&quot;&quot;
        timestamp = time.strftime(&quot;%H:%M:%S&quot;)
        full_message = f&quot;[{timestamp}] {sender}: {message}&quot;
        
        # Add to our list
        self.chat_messages.append(full_message)
        
        # Keep only last 10 messages
        if len(self.chat_messages) &gt; 10:
            self.chat_messages.pop(0)
        
        # Update the ScrollingFrame
        self.update_chat_scrolling()
    
    def update_chat_scrolling(self):
        &quot;&quot;&quot;Update the chat ScrollingFrame with current messages&quot;&quot;&quot;
        # Clear existing chat labels
        self.chat_scrolling.clear_children()
        
        # Add each message as a TextLabel
        for i, msg in enumerate(self.chat_messages):
            # Calculate position (starting from bottom)
            y_pos = 5 + (len(self.chat_messages) - i - 1) * 25
            
            # Create text label
            chat_label = TextLabel(5, y_pos, msg, 16, (230, 230, 255))
            self.chat_scrolling.add_child(chat_label)
    
    def update_player_movement(self, dt):
        &quot;&quot;&quot;Update local player movement&quot;&quot;&quot;
        if not self.local_player:
            return
        
        keys = pg.key.get_pressed()
        old_velocity = self.local_player.velocity.copy()
        self.local_player.velocity = [0, 0]
        
        if keys[pg.K_w] or keys[pg.K_UP]:
            self.local_player.velocity[1] = -1
        if keys[pg.K_s] or keys[pg.K_DOWN]:
            self.local_player.velocity[1] = 1
        if keys[pg.K_a] or keys[pg.K_LEFT]:
            self.local_player.velocity[0] = -1
        if keys[pg.K_d] or keys[pg.K_RIGHT]:
            self.local_player.velocity[0] = 1
        
        # Normalize diagonal movement
        if self.local_player.velocity[0] != 0 and self.local_player.velocity[1] != 0:
            self.local_player.velocity[0] *= 0.7071
            self.local_player.velocity[1] *= 0.7071
        
        # Only send update if velocity changed significantly
        velocity_changed = (
            abs(old_velocity[0] - self.local_player.velocity[0]) &gt; 0.1 or
            abs(old_velocity[1] - self.local_player.velocity[1]) &gt; 0.1
        )
        
        # Update position
        self.local_player.x += self.local_player.velocity[0] * self.local_player.speed * dt
        self.local_player.y += self.local_player.velocity[1] * self.local_player.speed * dt
        
        # Keep player in bounds
        self.local_player.x = max(20, min(1004, self.local_player.x))
        self.local_player.y = max(20, min(700, self.local_player.y))
        
        # Send update if moving or velocity changed
        if velocity_changed or self.local_player.velocity != [0, 0]:
            self.send_player_update()
    
    def update_player_list(self):
        &quot;&quot;&quot;Update player list UI&quot;&quot;&quot;
        player_text = f&quot;Players ({len(self.players)}):\n&quot;
        for player_id, player in self.players.items():
            is_local = &quot;â˜… &quot; if player_id == self.local_player.id else &quot;  &quot;
            player_text += f&quot;{is_local}{player.name}\n&quot;
        
        self.player_list_label.set_text(player_text)
    
    def disconnect(self):
        &quot;&quot;&quot;Disconnect from network and return to main menu&quot;&quot;&quot;
        print(&quot;Disconnecting...&quot;)
        
        # Clean up network connections
        if hasattr(self, &#x27;network_info&#x27;):
            if self.network_info.is_host and self.network_info.host:
                self.network_info.host.stop()
            elif self.network_info.client:
                self.network_info.client.disconnect()
        
        # Clear engine network info
        if hasattr(self.engine, &#x27;network_info&#x27;):
            self.engine.network_info = None
        
        # Go back to main menu
        self.engine.set_scene(&quot;main&quot;)
    
    def update(self, dt):
        # Process network messages
        self.process_network_messages()
        
        # Update player movement
        self.update_player_movement(dt)
        
        # Update UI
        self.update_player_list()
        
        return super().update(dt)
    
    def render(self, renderer):
        # Draw background
        renderer.fill_screen((30, 30, 40))
        
        # Draw grid
        grid_color = (50, 50, 60)
        for x in range(0, 1024, 50):
            renderer.draw_line(x, 0, x, 720, grid_color, 1)
        for y in range(0, 720, 50):
            renderer.draw_line(0, y, 1024, y, grid_color, 1)
        
        # Draw center point
        renderer.draw_circle(512, 360, 5, (100, 100, 150))
        
        # Draw all players
        for player_id, player in self.players.items():
            # Draw player body
            renderer.draw_rect(
                player.x - player.width/2,
                player.y - player.height/2,
                player.width,
                player.height,
                player.color
            )
            
            # Draw player name
            renderer.draw_text(str(player.name), player.x, player.y - 30,(255, 255, 255) if player_id != self.local_player.id else (255, 255, 0), FontManager.get_font(None, 16), anchor_point=(0.5, 0.5))
            
            # Draw local player indicator
            if player_id == self.local_player.id:
                renderer.draw_circle(player.x, player.y - 40, 5, (255, 255, 0))
                
                # Draw velocity indicator
                if player.velocity != [0, 0]:
                    end_x = player.x + player.velocity[0] * 30
                    end_y = player.y + player.velocity[1] * 30
                    renderer.draw_line(player.x, player.y, end_x, end_y, (255, 255, 0, 150), 2)
        
        # Draw instructions
        if not self.ui_visible:
            font = pg.font.SysFont(&quot;Arial&quot;, 18)
            instructions = [
                &quot;WASD or Arrow Keys - Move&quot;,
                &quot;ESC - Toggle UI&quot;,
                &quot;ENTER - Send chat message&quot;,
                &quot;Click Disconnect to leave&quot;
            ]
            
            for i, text in enumerate(instructions):
                text_surface = font.render(text, True, (200, 230, 255))
                renderer.blit(text_surface, (20, 20 + i * 30))
            
            # Draw connection info
            if hasattr(self, &#x27;network_info&#x27;) and self.network_info:
                mode = &quot;Host&quot; if self.network_info.is_host else &quot;Client&quot;
                info = f&quot;Connected as {mode} | Players: {len(self.players)}&quot;
                info_surface = font.render(info, True, (100, 255, 100))
                renderer.blit(info_surface, (20, 680))
        
        # Draw network status
        font = pg.font.SysFont(&quot;Arial&quot;, 14)
        if hasattr(self, &#x27;network_info&#x27;) and self.network_info:
            if self.network_info.is_host:
                if self.network_info.host:
                    client_count = self.network_info.host.get_client_count()
                    status_text = f&quot;Hosting | Clients: {client_count}&quot;
                else:
                    status_text = &quot;Host (disconnected)&quot;
            else:
                if self.network_info.client and self.network_info.client.connected:
                    status_text = &quot;Connected to server&quot;
                else:
                    status_text = &quot;Disconnected&quot;
        else:
            status_text = &quot;No connection&quot;
        
        status_surface = font.render(status_text, True, (200, 200, 200))
        renderer.blit(status_surface, (1024 - status_surface.get_width() - 20, 680))

def main():
    engine = LunaEngine(&#x27;LunaEngine - Multiplayer Demo&#x27;, 1024, 720, False)
    
    engine.add_scene(&#x27;main&#x27;, MainScene)
    engine.add_scene(&#x27;InGame&#x27;, InGameScene)
    engine.set_scene(&#x27;main&#x27;)
    
    print(&quot;=== LunaEngine Multiplayer Demo ===&quot;)
    print(&quot;Instructions:&quot;)
    print(&quot;1. For HOST: Check &#x27;Run as Host&#x27;, click &#x27;Start Host&#x27;&quot;)
    print(&quot;2. For CLIENT: Enter host IP (127.0.0.1 for local), click &#x27;Connect&#x27;&quot;)
    print(&quot;3. Click &#x27;Play&#x27; to enter game&quot;)
    print(&quot;4. In game: WASD to move, ESC to toggle UI, ENTER to chat&quot;)
    
    engine.run()

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
                    </div>
                </div>
            </div>
            <div class="col-lg-4">
                <div class="card shadow-sm sticky-top" style="top: 20px;">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0"><i class="bi bi-info-circle me-2"></i>About This Example</h5>
                    </div>
                    <div class="card-body">
                        <p>Start as host (server + client)</p>
                        <hr>
                        <div class="d-grid gap-2">
                            <a href="multiplayer_demo.py" download class="btn btn-outline-primary">
                                <i class="bi bi-download me-2"></i>Download Python File
                            </a>
                            <a href="index.html" class="btn btn-outline-secondary">
                                <i class="bi bi-arrow-left me-2"></i>Back to Examples Hub
                            </a>
                            <a href="../quick-start.html" class="btn btn-outline-success">
                                <i class="bi bi-play-circle me-2"></i>Quick Start Guide
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="footer-section">
        <div class="container">
            <div class="row">
                <div class="col-md-6">
                    <h5><i class="bi bi-moon-stars-fill me-2"></i>LunaEngine</h5>
                    <p class="text-white-50">2D Game Framework for Python</p>
                </div>
                <div class="col-md-6 text-end">
                    <p class="text-white-50">
                        <i class="bi bi-lightning-charge me-1"></i>
                        Documentation generated on 2026-02-16 14:06
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="theme.js"></script>
    
    <script>
    // Universal search handler
    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById('moduleSearch');
        const searchIcon = document.querySelector('.input-group-text');
        
        if (searchInput && searchIcon) {
            const performSearch = () => {
                const searchTerm = searchInput.value.trim();
                if (searchTerm) {
                    const currentPath = window.location.pathname;
                    let searchPath = 'search.html';
                    
                    // Adjust path based on current location
                    if (currentPath.split('/').filter(Boolean).length > 2) {
                        searchPath = '../search.html';
                    }
                    
                    window.location.href = `${searchPath}?q=${encodeURIComponent(searchTerm)}`;
                }
            };
            
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); 
                    e.stopPropagation();
                    performSearch();
                    return false;
                }
            });
            
            searchIcon.addEventListener('click', performSearch);
            
            const form = searchInput.closest('form');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    performSearch();
                    return false;
                });
            }
        }
    });
    </script>
    
    
</body>
</html>